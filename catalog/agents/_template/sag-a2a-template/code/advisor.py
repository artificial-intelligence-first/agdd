"""
YourA2AAdvisorSAG - A2A-enabled Template for Sub-Agent implementation

This template extends the standard SAG template with A2A (Agent-to-Agent) capabilities:
- Context Propagation: Preserves tracing context across agent calls
- Discovery: Can be discovered by other agents via API
- Enhanced Observability: Tracks A2A-specific metrics

Insert your domain-specific delegation logic before deploying to production.
"""

from __future__ import annotations

import time
from typing import Any, Dict


async def run(payload: Dict[str, Any], *, skills: Any = None, obs: Any = None) -> Dict[str, Any]:
    """
    Execute domain-specific logic with A2A support.

    Args:
        payload: Input data conforming to a2a_advisor_input schema
        skills: Skill execution runtime
        obs: Observability interface (logging/metrics)

    Returns:
        Output conforming to a2a_advisor_output schema
    """
    t0 = time.time()

    if obs:
        obs.log("start", {"agent": "YourA2AAdvisorSAG", "a2a_enabled": True})

    try:
        # ===== Extract A2A Context =====
        a2a_context = payload.get("context", {})
        correlation_id = a2a_context.get("correlation_id", "unknown")
        parent_run_id = a2a_context.get("parent_run_id", "unknown")
        call_chain = a2a_context.get("call_chain", [])
        call_depth = len(call_chain)

        if obs:
            obs.log(
                "a2a_context_received",
                {
                    "correlation_id": correlation_id,
                    "parent_run_id": parent_run_id,
                    "call_depth": call_depth,
                    "call_chain": call_chain,
                },
            )

        # Warn if call depth is too deep (potential circular dependency)
        if call_depth > 10:
            if obs:
                obs.log(
                    "a2a_deep_call_chain_warning",
                    {
                        "call_depth": call_depth,
                        "correlation_id": correlation_id,
                    },
                )

        # ===== Input Extraction =====
        # Map inbound payload fields into the structures your SAG expects.
        domain_field = payload.get("domain_field")
        parameters = payload.get("parameters", {})

        if obs:
            obs.log(
                "input_received",
                {
                    "domain_field": domain_field,
                    "parameters": parameters,
                    "correlation_id": correlation_id,
                },
            )

        # ===== Domain Logic =====
        # Replace this placeholder with your specialized processing pipeline.

        # Example: Invoke a skill if available
        processed_value = None
        skill_invoked = False

        if skills and skills.exists("skill.your-domain-skill"):
            try:
                skill_input = {
                    "field": domain_field,
                    "params": parameters,
                    # Optionally pass A2A context to skills
                    "context": {
                        "correlation_id": correlation_id,
                        "parent_run_id": obs.run_id if obs else "unknown",
                    },
                }
                skill_output = await skills.invoke_async("skill.your-domain-skill", skill_input)
                processed_value = skill_output.get("result")
                skill_invoked = True

                if obs:
                    obs.log(
                        "skill_invoked",
                        {
                            "skill": "skill.your-domain-skill",
                            "correlation_id": correlation_id,
                        },
                    )
            except Exception as e:
                if obs:
                    obs.log(
                        "skill_error",
                        {
                            "skill": "skill.your-domain-skill",
                            "error": str(e),
                            "correlation_id": correlation_id,
                        },
                    )
                # Fallback logic
                processed_value = f"fallback_{domain_field}"
        else:
            # Default logic when skill is unavailable
            processed_value = f"default_{domain_field}"

        # ===== Output Construction =====
        # Shape the response so it complies with a2a_advisor_output schema.
        duration_ms = int((time.time() - t0) * 1000)

        output = {
            "result": {
                "processed_field": processed_value,
                "details": {
                    "skill_invoked": skill_invoked,
                    "processing_time_ms": duration_ms,
                },
            },
            "confidence": 0.95,  # Replace with a calculated confidence metric.
            "notes": "Generated by YourA2AAdvisorSAG",
            "trace": {
                "correlation_id": correlation_id,
                "parent_run_id": parent_run_id,
                "processing_time_ms": duration_ms,
                "call_depth": call_depth,
                "run_id": obs.run_id if obs else "unknown",
            },
        }

        # ===== Observability =====
        if obs:
            obs.metric("latency_ms", duration_ms)
            obs.metric("a2a_depth", call_depth)
            # Add other metrics as needed
            # obs.metric("tokens", token_count)

            obs.log(
                "a2a_result_packaged",
                {
                    "correlation_id": correlation_id,
                    "confidence": output["confidence"],
                    "call_depth": call_depth,
                },
            )

            obs.log(
                "end",
                {
                    "status": "success",
                    "duration_ms": duration_ms,
                    "correlation_id": correlation_id,
                },
            )

        return output

    except Exception as e:
        duration_ms = int((time.time() - t0) * 1000)

        # Extract context for error logging
        a2a_context = payload.get("context", {})
        correlation_id = a2a_context.get("correlation_id", "unknown")

        if obs:
            obs.log(
                "error",
                {
                    "error": str(e),
                    "type": type(e).__name__,
                    "duration_ms": duration_ms,
                    "correlation_id": correlation_id,
                },
            )
            obs.metric("latency_ms", duration_ms)

        raise
